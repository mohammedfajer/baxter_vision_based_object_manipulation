#include <ros/ros.h>
#include <std_msgs/Float32MultiArray.h>

#include <tf/transform_listener.h>
#include <iostream>

#include <geometry_msgs/Pose.h>

#include <moveit_msgs/PlanningScene.h>
#include <moveit_msgs/AttachedCollisionObject.h>
#include <moveit_msgs/GetStateValidity.h>
#include <moveit_msgs/DisplayRobotState.h>
#include <moveit_msgs/DisplayTrajectory.h>

#include <moveit/robot_model_loader/robot_model_loader.h>
#include <moveit/robot_state/robot_state.h>
#include <moveit/robot_state/conversions.h>
#include <moveit/move_group_interface/move_group.h>

#include <string>
#include <vector>





class ObjectPose
{

    private:
        ros::NodeHandle node_object;
        tf::TransformListener transforms_listener;

    public:
        ObjectPose()
        {

        }

        void PrintObjectPose(tf::Vector3 displacement_vector, tf::Quaternion orientation_matrix)
        {
            std::cout << "Displacement Vector: (x, y, z) : ( " << displacement_vector.getX() <<
            ",  " << displacement_vector.getY() <<
            ",  " << displacement_vector.getZ() <<
            ")  " << std::endl;

            std::cout << std::endl;

            std::cout << "Rotation Matrix: (x, y, z, w) : ( " << orientation_matrix.getX() <<
            ",  " << orientation_matrix.getY() <<
            ",  " << orientation_matrix.getZ() <<
            ",  " << orientation_matrix.getW() <<
            ")  " << std::endl;
        }

        void Run()
        {
            ros::Rate rate(10.0);
            while(node_object.ok())
            {
                tf::StampedTransform transform;
                try
                {
                    transforms_listener.lookupTransform("/camera_link", "/object_29", ros::Time(0), transform);
                }
                catch(tf::TransformException& e)
                {
                    ROS_ERROR("%s", e.what());
                    ros::Duration(1.0).sleep();
                }

                tf::Vector3 translation = transform.getOrigin();
                tf::Quaternion rotation = transform.getRotation();
                // PrintObjectPose(translation, rotation);

                MoveToPose(translation, rotation, "left_arm");
                break;

                rate.sleep();
            }
        }


        void MoveToPose(tf::Vector3 position, tf::Quaternion orientation, std::string planning_group_name)
        {

            // MoveIt Setup
            static const std::string PLANNING_GROUP    = planning_group_name;
            moveit::planning_interface::MoveGroup move_group(PLANNING_GROUP);
            const robot_state::JointModelGroup* joint_model_group = move_group.getCurrentState()->getJointModelGroup(PLANNING_GROUP);

            // Rviz Visualizer
            ros::Publisher display_publisher = node_object.advertise<moveit_msgs::DisplayTrajectory>("/move_group/display_planned_path", 1, true);
            moveit_msgs::DisplayTrajectory display_trajectory;

            // Info
            // Robot Reference Frame
            ROS_INFO("Reference frame: %s", move_group.getPlanningFrame().c_str());

            // End-Effector Link for this group
            ROS_INFO("End effector link: %s", move_group.getEndEffectorLink().c_str());

            // Planning to a Pose Goal
            geometry_msgs::Pose target_pose;
            target_pose.orientation.w   =   orientation.getW();
            target_pose.position.x      =   position.getX();
            target_pose.position.y      =   position.getY();
            target_pose.position.z      =   position.getZ();

            // Call the planner to plan the trajectory
            moveit::planning_interface::MoveGroup::Plan my_plan;

            bool success = move_group.plan(my_plan);
            ROS_INFO("Visualizing plan 1 (pose goal) %s", success ? "SUCCESS" : "FAILED" );

            // Sleep to enable rviz to visualize data
            sleep(5.0);

            bool shouldVisualize = true;

            if(shouldVisualize)
            {
                ROS_INFO("Visualizing plan 1 (again)");
                display_trajectory.trajectory_start = my_plan.start_state_;
                display_trajectory.trajectory.push_back(my_plan.trajectory_);
                display_publisher.publish(display_trajectory);

                // Sleep to eable Rviz to visualize the plan
                sleep(5.0);
            }

            std::vector<double> group_variable_values;
            move_group.getCurrentState()->copyJointGroupPositions(move_group.getCurrentState()->getRobotModel()->getJointModelGroup(move_group.getName()), group_variable_values);

            group_variable_values[0] = -1.0;
            move_group.setJointValueTarget(group_variable_values);
            success = move_group.plan(my_plan);

            ROS_INFO("Visualizing plan 2 (joint space goal) %s",success?"":"FAILED");
            /* Sleep to give Rviz time to visualize the plan. */
            sleep(5.0);
        }
};

int main(int argc, char** argv)
{
    ros::init(argc, argv, "object_pose");
      ros::AsyncSpinner spinner(1);
  spinner.start();
    ObjectPose op;
    op.Run();

    return 0;
}

---------------------------------------------------PYTHON
#!/usr/bin/env python

import sys
import copy
import rospy
import moveit_commander
import geometry_msgs.msg
import moveit_msgs.msg
import tf


class PicknPlace:

    def __init__(self):
        rospy.init_node('pick_n_place', anonymous=True)
        self.tf_listener = tf.TransformListener()
        self.joint_state_topic = None 
        self.robot             = None 
        self.move_group        = None 
        self.scene             = None
        self.display_trajectory_publisher = None

        self.InitMoveIt()

    def InitMoveIt(self, group='left_arm'):
        self.joint_state_topic = ['joint_states:=/robot/joint_states']
        moveit_commander.roscpp_initializer(sys.argv)
        self.robot = moveit_commander.RobotCommander()
        self.move_group = moveit_commander.MoveGroupCommander(group)
        self.scene = moveit_commander.PlanningSceneInterface()

    def Run(self):
        while not rospy.is_shutdown():
            success = True 
            try:
                (translation, rotation) = self.tf_listener.lookupTransform('/camera_link', '/object_29', rospy.Time(0))
            except(tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
                success = False 
            if success:
                rospy.INFO('found tf')
                move_group = 'left_arm'
                self.MoveToPose(list(translation), list(rotation), move_group)
                
    
    def PrintBasicInfo(self):
        print('====== Reference Frame: {}'.format(self.move_group.get_planning_frame()))
        print('====== End-Effector Link: {}'.format(self.move_group.get_end_effector_link()))
        print('====== Groups Names: {}'.format(self.robot.get_group_names()))
        print('====== Printing Robot state: {}'.format(self.robot.get_current_state()))

    def MoveToPose(self, translation, rotation, move_group_name):

        self.display_trajectory_publisher = rospy.Publisher('/move_group/display_planned_path', moveit_msgs.msg.DisplayTrajectory)
        rospy.sleep(10)
        
        self.PrintBasicInfo()

        # Generationg plane 
        target_pose = geometry_msgs.msg.Pose()
        target_pose.position = geometry_msgs.msg.Point( translation[0], translation[1], translation[2] )
        target_pose.orientation = geometry_msgs.msg.Quaternion( rotation[0], rotation[1], rotation[2], 1.0 )

        self.move_group.set_pose_target(target_pose)

        plan1 = self.move_group.plan()

        print('======= Waiting while RVIZ displays plan1....')
        rospy.sleep()

        print('====== Visualizing plan1')
        display_trajectory = moveit_msgs.msg.DisplayTrajectory()
        display_trajectory.trajectory_start = self.robot.get_current_state()
        display_trajectory.trajectory.append(plan1)
        self.display_trajectory_publisher.publish(display_trajectory)

        print('===== Waiting while plan1 is visualized (again)... ')
        rospy.sleep(5)

        # Moving to a pose goal
        if not plan1.joint_trajectory.points:
            print "[ERROR] No trajectory found"
        else:
            self.move_group.go(wait=True)
    
        moveit_commander.roscpp_shutdown()
        moveit_commander.os._exit(0)
    
if __name__ == "__main__":
    try:
        pnp=PicknPlace()
        pnp.Run()
    except rospy.ROSInterruptException:
        pass




----------------------------------------------

'''
    get moveit to work with baxter
    get baxter to plan and move to a predefined location
'''

''' 
    sequence of execution
    enable the robot
    start the joint trajectory controller
    launch the rethink electric grippers and rviz 
'''

'''
    how to use moveit in python
    how to use it with the scene objects and avoiding collisions
'''

